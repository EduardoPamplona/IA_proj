import copy
import sys
from search import Problem, Node, depth_first_tree_search, breadth_first_tree_search, astar_search, recursive_best_first_search
import time

# numbrix.py: Template para implementacao do projeto de Inteligencia Artificial 2021/2022.
# Devem alterar as classes e funcoes neste ficheiro de acordo com as instrucoes do enunciado.
# Alem das funcoes e classes ja definidas, podem acrescentar outras que considerem pertinentes.

# Grupo 26:
# 96858 Eduardo Duarte Silva Rangel Pamplona
# 96885 Jose Maria de Oliveira Soares Bonneville Franco

class NumbrixState:
    state_id = 0

    def __init__(self, board):
        self.board = board
        self.id = NumbrixState.state_id
        NumbrixState.state_id += 1

    def __lt__(self, other):
        return self.id < other.id 

    def get_board(self):
        return self.board


class Board:
    """ Representacao interna de um tabuleiro de Numbrix. """

    def __init__(self, size: int, initial_positions, on_board: dict, off_board: dict):
        """ O construtor especifica o estado inicial. """
        self.size = size
        self.positions = initial_positions
        self.on_board = on_board
        self.off_board = off_board
        self.coordinate_on_off_dict()

    def get_size(self):
        return self.size

    def get_number(self, row: int, col: int):
        """ Devolve o valor na respetiva posicao do tabuleiro. """
        return self.positions[row][col]

    def set_number(self, row: int, col: int, num: int):
        self.positions[row][col] = num    
    
    def adjacent_vertical_numbers(self, row: int, col: int):
        """ Devolve os valores imediatamente abaixo e acima, 
        respectivamente. """
        if row == 0:
            up = None
        else:
            up = self.get_number(row - 1, col)
        if row == self.size - 1:
            down = None
        else:
            down = self.get_number(row + 1, col)
        return (up, down)
    
    def adjacent_horizontal_numbers(self, row: int, col: int):
        """ Devolve os valores imediatamente a esquerda e a direita, 
        respectivamente. """
        if col == 0:
            left = None
        else:
            left = self.get_number(row, col - 1)
        if col == self.size - 1:
            right = None
        else:
            right = self.get_number(row, col + 1)
        return (left, right)

    def set_positions(self, positions):
        self.positions = positions

    def coordinate_on_off_dict(self):
        board_changed = True
        prev_value = ()
        next_value = ()
        off_board_index = 0
        
        while board_changed or off_board_index < len(self.off_board):
            if board_changed:
                sorted_on_board = dict(sorted(self.on_board.items(), key = lambda item: item[1]))
            off_board_index = 0
            for key in self.off_board:
                for value in sorted_on_board.values():
                    if value < key:
                        (prev_row, prev_col) = get_key(value)
                        prev_value = (prev_row, prev_col, value)
                    else:
                        (next_row, next_col) = get_key(value)
                        next_value = (next_row, next_col, value)
                        break   
                possible_positions = self.manhattan_interception(key, prev_value, next_value)
                if len(possible_positions) == 1:
                    sorted_on_board[possible_positions[0]] = key
                    del self.off_board[key]
                    self.set_number(possible_positions[0][0], possible_positions[0][1], key)
                    board_changed = True
                    break
                else:
                    self.off_board[key] = possible_positions
                    board_changed = False
                off_board_index += 1  
        self.on_board = sorted_on_board              

        
    def manhattan_interception(self, num: int, lower_pos: tuple, higher_pos: tuple):
        possible_positions = []

        (lower_up, lower_down) = self.adjacent_vertical_numbers(lower_pos[0], lower_pos[1])
        (lower_left, lower_right) = self.adjacent_horizontal_numbers(lower_pos[0], lower_pos[1])

        (higher_up, higher_down) = self.adjacent_vertical_numbers(higher_pos[0], higher_pos[1])
        (higher_left, higher_right) = self.adjacent_horizontal_numbers(higher_pos[0], higher_pos[1])

        lower_diff = abs(lower_pos[2] - num)
        higher_diff = abs(higher_pos[2] - num)

        if lower_diff % 2 != 0:
            for i in range(lower_diff / 2):
                
                   
        return possible_positions
    

    def to_string(self):
        out = ""
        for r in range(self.size):
            c = 0
            for c in range(self.size):
                out += str(self.positions[r][c])
                if c != self.size - 1:
                    out += '\t'
            if r < self.size - 1:
                out += '\n'

        return out


    @staticmethod    
    def parse_instance(filename: str):
        """ Le o ficheiro cujo caminho e passado como argumento e retorna
        uma instancia da classe Board. """

        with open(filename, 'r') as file:
            data = file.read()

        it = 1
        size_str = ''
        for item in data:
            if item != '\n':
                it += 1
                size_str += item
            else:
                break
        size = int(size_str)   

        on_board = {}
        off_board = {}

        for i in range(size * size):
            off_board[i + 1] = []

        r = 0
        c = 0

        initial_positions = []
        row = []
        num = ''
        for item in data[it::]:
            if item != '\t' and item != '\n':
                num += item
            elif item == '\t':
                row.append(int(num))
                if int(num) != 0:
                    on_board[(r, c)] = int(num)
                    del off_board[int(num)]
                num = ''
                c += 1
            elif item == '\n':
                row.append(int(num))
                if int(num) != 0:
                    on_board[(r, c)] = int(num)
                    del off_board[int(num)]
                num = ''
                initial_positions.append(row)
                r += 1
                c = 0
                row = []       

        return Board(size, initial_positions, on_board, off_board)


class Numbrix(Problem):
    def __init__(self, board: Board):
        """ O construtor especifica o estado inicial. """
        self.initial = NumbrixState(board)

    def actions(self, state: NumbrixState):
        board = state.get_board()
        return actions

    def result(self, state: NumbrixState, action):
        """ Retorna o estado resultante de executar a 'action' sobre
        'state' passado como argumento. A acoo a executar deve ser uma
        das presentes na lista obtida pela execucao de 
        self.actions(state). """

        board = state.get_board()  

        new_board = copy.deepcopy(board)
        new_board.set_number(action[0], action[1], action[2])

        new_state = NumbrixState(new_board)

        return new_state

    def goal_test(self, state: NumbrixState):
        """ Retorna True se e so se o estado passado como argumento e
        um estado objetivo. Deve verificar se todas as posicoes do tabuleiro 
        estao preenchidas com uma sequencia de numeros adjacentes. """

        board = state.get_board()
        current_pos = board.get_lowest_number_put()

        if current_pos[2] != 1:
            return False
        else:
            while True:

                (up, down) = board.adjacent_vertical_numbers(current_pos[0], current_pos[1])
                (left, right) = board.adjacent_horizontal_numbers(current_pos[0], current_pos[1])

                if up == current_pos[2]+1:
                    current_pos = (current_pos[0]-1, current_pos[1], current_pos[2]+1)
                elif down == current_pos[2]+1:
                    current_pos = (current_pos[0]+1, current_pos[1], current_pos[2]+1)
                elif left == current_pos[2]+1:
                    current_pos = (current_pos[0], current_pos[1]-1, current_pos[2]+1)
                elif right == current_pos[2]+1:
                    current_pos = (current_pos[0], current_pos[1]+1, current_pos[2]+1)
                else:
                    if current_pos[2] == board.get_size() * board.get_size():
                        return True
                    return False
                
    def h(self, node: Node):
        """ Funcao heuristica utilizada para a procura A*. """
        # TODO
        pass
    

if __name__ == "__main__":

    start_time = time.time()

    inputFile = sys.argv[1]

    board = Board.parse_instance(inputFile)
    
    # problem = Numbrix(board)

    # goal_node = breadth_first_tree_search(problem)

    # print(goal_node.state.get_board().to_string())

    # print("--- %s seconds ---" % (time.time() - start_time))
